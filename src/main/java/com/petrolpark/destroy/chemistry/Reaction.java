package com.petrolpark.destroy.chemistry;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;
import java.util.function.BiFunction;
import java.util.function.Consumer;

import com.petrolpark.destroy.Destroy;

public class Reaction {

    /**
     * The set of all Reactions known to Destroy, indexed by their {@link id IDs}.
     */
    public static final Map<String, Reaction> REACTIONS = new HashMap<>();

    public static ReactionBuilder generatedReactionBuilder() {
        return new ReactionBuilder(new Reaction("novel"), true);
    };

    private Map<Molecule, Integer> reactants, products, orders;

    private ReactionResult result;

    private float preexponentialFactor;
    private float activationEnergy;

    private String nameSpace;
    private String id;

    private boolean includeInJei;
    private boolean displayAsReversible;

    public static final Float GAS_CONSTANT = 8.3145f;

    /**
     * Get the Reaction with the given {@link Reaction#getFullId ID}.
     * @param reactionId In the format {@code <namespace>:<id>}
     * @return {@code null} if no Reaction exists with that ID
     */
    public static Reaction get(String reactionId) {
        return REACTIONS.get(reactionId);
    };

    private Reaction(String nameSpace) {
        this.nameSpace = nameSpace;
    };

    /**
     * Whether this Molecule gets consumed in this Reaction (does not include catalysts).
     */
    public Boolean containsReactant(Molecule molecule) {
        return this.reactants.keySet().contains(molecule);
    };

    /**
     * Whether this Molecule is created in this Reaction.
     */
    public Boolean containsProduct(Molecule molecule) {
        return this.products.keySet().contains(molecule);
    };

    /**
     * All Molecules which are consumed in this Reaction (but not their molar ratios).
     */
    public Set<Molecule> getReactants() {
        return this.reactants.keySet();
    };

    /**
     * All Molecules which are created in this Reaction (but not their molar ratios).
     */
    public Set<Molecule> getProducts() {
        return this.products.keySet();
    };

    /**
     * The rate constant of this Reaction at the given temperature.
     * @param temperature (in kelvins).
     */
    public float getRateConstant(float temperature) {
        return preexponentialFactor * (float)Math.exp(-((activationEnergy * 1000) / (GAS_CONSTANT * temperature)));
    };

    /**
     * Whether this Reaction has a {@link ReactionResult Result}. 
     */
    public boolean hasResult() {
        return result != null;
    };

    /**
     * The {@link ReactionResult Result} of this Reaction, which occurs once a set
     * number of moles of Reaction have occured.
     * @return {@code null} if this Reaction has no result.
     */
    public ReactionResult getResult() {
        return result;
    };

    /**
     * The unique identifier for this Reaction (not including its namespace), which
     * also acts as its translation key. {@code <namespace>.reaction.<id>} should hold
     * the name of this Reaction, and {@code <namespace>.reaction.<id>.description}
     * should hold the description of this Reaction.
     * @see Reaction#getFullId Get the full ID
     */
    public String getId() {
        return id;
    };

    /**
     * Get the fully unique ID for this Reaction, in the format {@code <namespace>:
     * <id>}, for example {@code destroy:chloroform_fluorination}.
     */
    public String getFullId() {
        return nameSpace + ":" + id;
    };

    /**
     * Whether this Reaction should be displayed in the list of Reactions in JEI.
     */
    public boolean includeInJei() {
        return includeInJei;
    };

    /**
     * Whether this Reaction should be displayed in JEI with an equilibrium arrow rather than a normal one.
     */
    public boolean displayAsReversible() {
        return displayAsReversible;
    };

    /**
     * The name space of the mod by which this Reaction was defined.
     * @return {@code "novel"} if this was generated automatically by a {@link com.petrolpark.destroy.chemistry.genericreaction.GenericReaction Reaction generator}.
     */
    public String getNameSpace() {
        return nameSpace;
    };

    public Integer getReactantMolarRatio(Molecule reactant) {
        if (!reactants.keySet().contains(reactant)) {
            return 0;
        } else {
            return reactants.get(reactant);
        }
    };

    public Integer getProductMolarRatio(Molecule product) {
        if (!products.keySet().contains(product)) {
            return 0;
        } else {
            return products.get(product);
        }
    };

    public Map<Molecule, Integer> getOrders() {
        return this.orders;
    };

    public static class ReactionBuilder {

        private String namespace;

        /**
         * Whether this Reaction is being generated by a {@link GenericReaction Generic Reaction generator}.
         */
        final boolean generated;
        Reaction reaction;

        private boolean hasForcedPreExponentialFactor;
        private boolean hasForcedActivationEnergy;

        private ReactionBuilder(Reaction reaction, boolean generated) {
            this.generated = generated;
            this.reaction = reaction;

            reaction.reactants = new HashMap<>();
            reaction.products = new HashMap<>();
            reaction.orders = new HashMap<>();

            reaction.includeInJei = true;

            hasForcedPreExponentialFactor = false;
            hasForcedActivationEnergy = false;
        };

        public ReactionBuilder(String namespace) {
            this(new Reaction(namespace), false);
            this.namespace = namespace;
        };

        /**
         * Add a {@link Molecule} of which one mole will be consumed per mole of Reaction.
         * By default, the order of rate of reaction with respect to this Molecule will be one.
         * @param molecule
         * @return This Reaction Builder
         * @see ReactionBuilder#addReactant(Molecule, int) Adding a different stoichometric ratio
         * @see ReactionBuilder#addReactant(Molecule, int, int) Adding a Molecule with a different order
         */
        public ReactionBuilder addReactant(Molecule molecule) {
            return addReactant(molecule, 1);
        };

        /**
         * Add a {@link Molecule} of which {@code ratio} moles will be consumed per mole of Reaction.
         * By default, the order of rate of reaction with respect to this Molecule will be one.
         * @param molecule
         * @param ratio The stoichometric ratio of this reactant in this Reaction
         * @return This Reaction Builder
         * @see ReactionBuilder#addReactant(Molecule, int, int) Adding a Molecule with a different order
         */
        public ReactionBuilder addReactant(Molecule molecule, int ratio) {
            return addReactant(molecule, ratio, ratio);
        };

        /**
         * Add a {@link Molecule} which will be consumed in this Reaction.
         * @param molecule
         * @param ratio The stoichometric ratio of this reactant in this Reaction
         * @param order The order of the rate of the Reaction with respect to this Molecule
         * @return This Reaction Builder
         */
        public ReactionBuilder addReactant(Molecule molecule, int ratio, int order) {
            reaction.reactants.put(molecule, ratio);
            reaction.orders.put(molecule, order);
            return this;
        };

        /**
         * Sets the order of rate of Reaction of the given {@link Molecule}.
         * @param molecule If this is not a reactant of this Reaction, an error will be thrown
         * @param order
         * @return This Reaction Builder
         * @see ReactionBuilder#addCatalyst(Molecule, int) Adding order with respect to a Molecule that is not a reactant (i.e. a catalyst)
         */
        public ReactionBuilder setOrder(Molecule molecule, int order) {
            if (!reaction.reactants.keySet().contains(molecule)) throw new IllegalStateException("Cannot modify order of a Molecule that is not a reactant.");
            addCatalyst(molecule, order);
            return this;
        };

        /**
         * Add a {@link Molecule} of which one mole will be produced per mole of Reaction.
         * @param molecule
         * @return This Reaction Builder
         */
        public ReactionBuilder addProduct(Molecule molecule) {
            return addProduct(molecule, 1);
        };

        /**
         * Add a {@link Molecule} of which {@code ratio} moles will be produced per mole of Reaction.
         * @param molecule
         * @param ratio The stoichometric ratio of this product in this Reaction
         * @return This Reaction Builder
         * @see ReactionBuilder#addProduct(Molecule, int) Adding a different stoichometric ratio
         */
        public ReactionBuilder addProduct(Molecule molecule, int ratio) {
            reaction.products.put(molecule, ratio);
            return this;
        };

        /**
         * Add a {@link Molecule} which does not get consumed in this Reaction, but which affects the rate.
         * @param molecule
         * @param order If this is is 0, the rate will not be affected but the Molecule will need to be present for the Reaction to proceed
         * @return This Reaction Builder
         */
        public ReactionBuilder addCatalyst(Molecule molecule, int order) {
            reaction.orders.put(molecule, order);
            return this;
        };

        /**
         * Don't include this Reaction in the list of Reactions shown in JEI.
         * @return This Reaction Builder
         */
        public ReactionBuilder dontIncludeInJei() {
            reaction.includeInJei = false;
            return this;
        };

        /**
         * Set the ID for the Reaction. The title and description of the Reaction will be looked for at {@code "<namespace>.reaction.<id>"}.
         * @param id A unique string
         * @return This Reaction Builder
         */
        public ReactionBuilder id(String id) {
            reaction.id = id;
            return this;
        };

        /**
         * Set the pre-exponential factor in the Arrhenius equation for this Reaction.
         * @param preexponentialFactor
         * @return This Reaction Builder
         */
        public ReactionBuilder preexponentialFactor(float preexponentialFactor) {
            reaction.preexponentialFactor = preexponentialFactor;
            hasForcedPreExponentialFactor = true;
            return this;
        };

        /**
         * Set the activation energy (in kJ/mol) for this Reaction.
         * If no activation energy is given, defaults to 100kJ/mol.
         * @param activationEnergy
         */
        public ReactionBuilder activationEnergy(float activationEnergy) {
            reaction.activationEnergy = activationEnergy;
            hasForcedActivationEnergy = true;
            return this;
        };

        /**
         * Set the {@link ReactionResult Reaction Result} for this Reaction.
         * Use a {@link com.petrolpark.destroy.chemistry.reactionresult.CombinedReactionResult CombinedReactionResult} to set multiple]
         * @return This Reaction Builder
         */
        public ReactionBuilder withResult(float moles, BiFunction<Float, Reaction, ReactionResult> reactionresultFactory)  {
            if (reaction.result != null) throw new IllegalStateException("Reaction already has a Reaction Result. Use a CombinedReactionResult to have multiple.");
            reaction.result = reactionresultFactory.apply(moles, reaction);
            return this;
        };

        /**
         * Register a reverse Reaction for this Reaction.
         * <p>This reverse Reaction will have opposite {@link ReactionBuilder#addReactant reactants} and {@link ReactionBuilder#addProduct products},
         * but all the same {@link ReactionBuilder#addCatalyst catalysts}. It will {@link ReactionBuilder#dontIncludeInJei not be shown in JEI}, but
         * the original Reaction will include the reverse symbol.</p>
         * <p>The reverse Reaction does not automatically add Item Stack reactants, products or catalysts.</p>
         * @param reverseReactionModifier A consumer which gets passed the Builder of the reverse Reaction once its reactants, products and catalysts
         * have been added. This allows you to add {@link ReactionBuilder#setOrder orders with respect to the new reactants}, and {@link ReactionBuilder#withResult 
         * Reaction results}.
         * @return This Reaction Builder (not the reverse Reaction Builder)
         */
        public ReactionBuilder reverseReaction(Consumer<ReactionBuilder> reverseReactionModifier) {
            if (generated) throw new IllegalStateException("Generated Reactions cannot be reversible. Add another Generic Reaction instead.");
            reaction.displayAsReversible = true;
            ReactionBuilder reverseBuilder = new ReactionBuilder(namespace);
            for (Entry<Molecule, Integer> reactant : reaction.reactants.entrySet()) {
                reverseBuilder.addProduct(reactant.getKey(), reactant.getValue());
            };
            for (Entry<Molecule, Integer> product : reaction.products.entrySet()) {
                reverseBuilder.addReactant(product.getKey(), product.getValue());
            };
            for (Entry<Molecule, Integer> rateAffecter : reaction.orders.entrySet()) {
                if (reaction.reactants.keySet().contains(rateAffecter.getKey())) continue; // Ignore reactants, only add catalysts
                reverseBuilder.addCatalyst(rateAffecter.getKey(), rateAffecter.getValue());
            };
            reverseBuilder
                .id(reaction.id + ".reverse")
                .dontIncludeInJei();
            reverseReactionModifier.accept(reverseBuilder);
            reverseBuilder.build();
            return this;
        };

        public Reaction build() {

            if (reaction.id == null && !generated) {
                throw new IllegalStateException("Reaction '"+reactionString()+"' is missing an ID.");
            };

            if (!hasForcedActivationEnergy || reaction.activationEnergy <= 0f) {
                reaction.activationEnergy = 50f;
                Destroy.LOGGER.warn("Activation energy of reaction '"+reactionString()+"' was missing or invalid, so estimated as 100kJ.");
            };

            if (!hasForcedPreExponentialFactor || reaction.preexponentialFactor <= 0f) {
                reaction.preexponentialFactor = 1e8f;
                Destroy.LOGGER.warn("Pre-exponential factor of reaction '"+reactionString()+"' was missing or invalid, so was estimated as 1e6.");
            };

            if (!generated) {
                for (Molecule reactant : reaction.reactants.keySet()) {
                    reactant.addReactantReaction(reaction);
                };
                for (Molecule product : reaction.products.keySet()) {
                    product.addProductReaction(reaction);
                };
                REACTIONS.put(reaction.getFullId(), reaction);
            };
            
            return reaction;
        };

        private String reactionString() {
            String reactionString = "";
            for (Molecule reactant : reaction.reactants.keySet()) {
                reactionString += reactant.getSerlializedMolecularFormula();
                reactionString += " + ";
            };
            reactionString = reactionString.substring(0, reactionString.length() - 3) + " => ";
            for (Molecule product : reaction.products.keySet()) {
                reactionString += product.getSerlializedMolecularFormula();
                reactionString += " + ";
            };
            reactionString = reactionString.substring(0, reactionString.length() - 3);
            return reactionString;
        };
    };
}
