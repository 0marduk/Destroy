package com.petrolpark.destroy.chemistry;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.BiFunction;

import com.petrolpark.destroy.Destroy;

public class Reaction {

    /**
     * The set of all Reactions known to Destroy, indexed by their {@link id IDs}.
     */
    public static final Map<String, Reaction> REACTIONS = new HashMap<>();

    public static ReactionBuilder generatedReactionBuilder() {
        return new ReactionBuilder(new Reaction("novel"), true);
    };

    private Map<Molecule, Integer> reactants, products, orders;

    private ReactionResult result;

    private float preexponentialFactor;
    private float activationEnergy;

    private String nameSpace;
    private String id;

    public static final Float GAS_CONSTANT = 8.3145f;

    /**
     * Get the Reaction with the given {@link Reaction#getFullId ID}.
     * @param reactionId In the format {@code <namespace>:<id>}
     * @return {@code null} if no Reaction exists with that ID
     */
    public static Reaction get(String reactionId) {
        return REACTIONS.get(reactionId);
    };

    private Reaction(String nameSpace) {
        this.nameSpace = nameSpace;
    };

    /**
     * Whether this Molecule gets consumed in this Reaction (does not include catalysts).
     */
    public Boolean containsReactant(Molecule molecule) {
        return this.reactants.keySet().contains(molecule);
    };

    /**
     * Whether this Molecule is created in this Reaction.
     */
    public Boolean containsProduct(Molecule molecule) {
        return this.products.keySet().contains(molecule);
    };

    /**
     * All Molecules which are consumed in this Reaction (but not their molar ratios).
     */
    public Set<Molecule> getReactants() {
        return this.reactants.keySet();
    };

    /**
     * All Molecules which are created in this Reaction (but not their molar ratios).
     */
    public Set<Molecule> getProducts() {
        return this.products.keySet();
    };

    /**
     * The rate constant of this Reaction at the given temperature.
     * @param temperature (in kelvins).
     */
    public float getRateConstant(float temperature) {
        return preexponentialFactor * (float)Math.exp(-((activationEnergy * 1000) / (GAS_CONSTANT * temperature)));
    };

    /**
     * The {@link ReactionResult Result} of this Reaction, which occurs once a set
     * number of moles of Reaction have occured.
     * @return {@code null} if this Reaction has no result.
     */
    public ReactionResult getResult() {
        return result;
    };

    /**
     * The unique identifier for this Reaction (not including its namespace), which
     * also acts as its translation key. {@code <namespace>.reaction.<id>} should hold
     * the name of this Reaction, and {@code <namespace>.reaction.<id>.description}
     * should hold the description of this Reaction.
     * @see Reaction#getFullId Get the full ID
     */
    public String getId() {
        return id;
    };

    /**
     * Get the fully unique ID for this Reaction, in the format {@code <namespace>:
     * <id>}, for example {@code destroy:chloroform_fluorination}.
     */
    public String getFullId() {
        return nameSpace + ":" + id;
    };

    /**
     * The name space of the mod by which this Reaction was defined.
     * @return {@code "novel"} if this was generated automatically by a {@link com.petrolpark.destroy.chemistry.genericReaction.GenericReaction Reaction generator}.
     */
    public String getNameSpace() {
        return nameSpace;
    };

    public Integer getReactantMolarRatio(Molecule reactant) {
        if (!reactants.keySet().contains(reactant)) {
            return 0;
        } else {
            return reactants.get(reactant);
        }
    };

    public Integer getProductMolarRatio(Molecule product) {
        if (!products.keySet().contains(product)) {
            return 0;
        } else {
            return products.get(product);
        }
    };

    public Map<Molecule, Integer> getOrders() {
        return this.orders;
    };

    public static class ReactionBuilder {

        /**
         * Whether this Reaction is being generated by a {@link GenericReaction Generic Reaction generator}.
         */
        final boolean generated;
        Reaction reaction;

        private boolean hasForcedPreExponentialFactor;
        private boolean hasForcedActivationEnergy;

        private ReactionBuilder(Reaction reaction, boolean generated) {
            this.generated = generated;
            this.reaction = reaction;

            reaction.reactants = new HashMap<>();
            reaction.products = new HashMap<>();
            reaction.orders = new HashMap<>();

            hasForcedPreExponentialFactor = false;
            hasForcedActivationEnergy = false;
        };

        public ReactionBuilder(String namespace) {
            this(new Reaction(namespace), false);
        };

        public ReactionBuilder addReactant(Molecule molecule) {
            return addReactant(molecule, 1);
        };

        public ReactionBuilder addReactant(Molecule molecule, int ratio) {
            return addReactant(molecule, ratio, ratio);
        };

        public ReactionBuilder addReactant(Molecule molecule, int ratio, int order) {
            reaction.reactants.put(molecule, ratio);
            reaction.orders.put(molecule, order);
            return this;
        };

        public ReactionBuilder addProduct(Molecule molecule) {
            return addProduct(molecule, 1);
        };

        public ReactionBuilder addProduct(Molecule molecule, int ratio) {
            reaction.products.put(molecule, ratio);
            return this;
        };

        public ReactionBuilder addCatalyst(Molecule molecule, int order) {
            reaction.orders.put(molecule, order);
            return this;
        };

        /**
         * Set the ID for the Reaction.
         * @param id
         * @return This Reaction Builder
         */
        public ReactionBuilder id(String id) {
            reaction.id = id;
            return this;
        };

        /**
         * The pre-exponential factor in the Arrhenius equation for this Reaction.
         * @param preexponentialFactor
         * @return This Reaction Builder
         */
        public ReactionBuilder preexponentialFactor(float preexponentialFactor) {
            reaction.preexponentialFactor = preexponentialFactor;
            hasForcedPreExponentialFactor = true;
            return this;
        };

        /**
         * The activation energy (in kJ/mol) for this Reaction.
         * If no activation energy is given, defaults to 100kJ/mol.
         * @param activationEnergy
         */
        public ReactionBuilder activationEnergy(float activationEnergy) {
            reaction.activationEnergy = activationEnergy;
            hasForcedActivationEnergy = true;
            return this;
        };

        /**
         * Set the {@link ReactionResult Reaction Result} for this Reaction.
         * Use a {@link reactionResult.CombinedReactionResult} to set multiple]
         * @return This Reaction Builder
         */
        public ReactionBuilder withResult(float moles, BiFunction<Float, Reaction, ReactionResult> reactionResultFactory) {
            reaction.result = reactionResultFactory.apply(moles, reaction);
            return this;
        };

        public Reaction build() {

            if (reaction.id == null && !generated) {
                throw new IllegalStateException("Reaction '"+reactionString()+"' is missing an ID.");
            };

            if (!hasForcedActivationEnergy || reaction.activationEnergy <= 0f) {
                reaction.activationEnergy = 100f;
                Destroy.LOGGER.warn("Activation energy of reaction '"+reactionString()+"' was missing or invalid, so estimated as 100kJ.");
            };

            if (!hasForcedPreExponentialFactor || reaction.preexponentialFactor <= 0f) {
                reaction.preexponentialFactor = 1e6f;
                Destroy.LOGGER.warn("Pre-exponential factor of reaction '"+reactionString()+"' was missing or invalid, so was estimated as 1e6.");
            };

            if (!generated) {
                for (Molecule reactant : reaction.reactants.keySet()) {
                    reactant.addReactantReaction(reaction);
                };
                for (Molecule product : reaction.products.keySet()) {
                    product.addProductReaction(reaction);
                };
                REACTIONS.put(reaction.getFullId(), reaction);
            };
            
            return reaction;
        };

        private String reactionString() {
            String reactionString = "";
            for (Molecule reactant : reaction.reactants.keySet()) {
                reactionString += reactant.getSerlializedMolecularFormula();
                reactionString += " + ";
            };
            reactionString = reactionString.substring(0, reactionString.length() - 3) + " => ";
            for (Molecule product : reaction.products.keySet()) {
                reactionString += product.getSerlializedMolecularFormula();
                reactionString += " + ";
            };
            reactionString = reactionString.substring(0, reactionString.length() - 3);
            return reactionString;
        };
    };
}
